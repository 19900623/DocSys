/*
Navicat MySQL Data Transfer

Source Server         : wuyong
Source Server Version : 50635
Source Host           : wuyong.fullstack.club:3306
Source Database       : wiki

Target Server Type    : MYSQL
Target Server Version : 50635
File Encoding         : 65001

Date: 2017-05-24 19:34:08
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for wiki_doc
-- ----------------------------
DROP TABLE IF EXISTS `wiki_doc`;
CREATE TABLE `wiki_doc` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `content` longtext COMMENT '文章内容',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=79 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of wiki_doc
-- ----------------------------
INSERT INTO `wiki_doc` VALUES ('9', '# 可视化领域专用编程语言 dragon-lang（龙语）设计\n\n虽然 dragon 系统看起来是一种简单的可视化流程生成工具。但实际上它也是一门图灵完备的编程语言。（如果你愿意，甚至可以用它来重写操作系统）\n\ndragon-lang 是一门可视化的编程语言，基本语句由组件拖拽生成。 dragon-lang 是一门强类型的编程语言，有自己的类型系统。 dragon-lang 是一门领域专用语言，通过拓展组件，来适用特定领域的编程需求。\n\n\n##变量\n\n在程序运行中，值可变的量叫做变量。变量由类型，变量名，值三个要素组成。在 dragon-lang 中，变量按照作用范围可分为：模型变量，全局变量，xml 变量，局部变量。\n\n###变量类型\n\n\n| 分类 |	类型| 	签名| 	说明|\n| --- | --- | --- |\n| 基本类型 |	boolen|	N|	只能是 true 和 false 的布尔值|\n|| byte| 	B|	8 bit 宽的整数变量类型|\n|| int| 	I	|32 bit 宽的整数变量类型|\n|| long|	L	|64 bit 宽的整数变量类型|\n|| float|	F	|32 bit 宽的浮点数变量类型|\n|| double|	D	|64 bit 宽的浮点数变量类型|\n|| string|	S	|字符串变量类型|\n|| datatime|	T	|时间变量类型|\n|| 任意类型	|X	|任意变量类型|\n| 引用类型	|list	|[]	|相同类型的一组变量|\n|| map	|{}	|key - value 形式描述的一组变量|\n\n\n###变量作用范围\n\n#### xml 变量\nxml 变量被存放在 Frame 数据结构中，可以使用 xml.xxx 被全局的访问。\n\n#### 模型变量\n模型变量被存放在模型空间，可以使用 m.xxx 被全局的访问。\n\n#### 全局变量\n全局变量被存放在全局堆空间，可以使用 g.xxx 被全局访问。\n\n#### 局部变量\n局部变量被存放在栈空间，可以使用变量名直接被访问。但是局部变量的生存范围只在当前作用域，在当前作用域和当前作用域的子作用域可以被访问。在当前作用域外不能被访问。\n\n**注意**：\n作用域覆盖：当子作用域存在和父作用域同名的变量时，在子作用域使用名字访问的是子作用域的变量。当出了子作用域后，父作用域的变量恢复可见性。\n\n\n##异常\n-  DragonException 所有异常\n-  EngineException 执行器异常\n-  ExpressionException 表达式异常\n-  ProcessCreateException 组件创建异常\n-  ProcessRunException 组件运行异常\n-  ParamException 组件参数不符\n-  VerifyException 参数校验异常');
INSERT INTO `wiki_doc` VALUES ('10', '#运维部署\n\n如果你的工作是负责将已经发布的包部署到生产环境，这里的内容就是你需要知道的。\n\n\n## 认识 dragon 发布包的种类\n\ndragon 系统生成的流程可以被打包为：\n- 独立运行的 jar 文件\n	一个以 `.jar` 结尾的文件\n- 在容器中运行的 war 文件\n	一个以 `.war` 结尾的文件\n- 在 jstorm 集群中运行的 drpc.jar 组件\n	一个以 `.drpc.jar` 结尾的文件\n\n\n');
INSERT INTO `wiki_doc` VALUES ('11', '#流程开发\n\n如果你的工作是使用组件开发业务流程，这里的内容就是你需要的。');
INSERT INTO `wiki_doc` VALUES ('20', '#组件开发\n\n如果你的工作是开发 dragon 系统的组件，这里的内容就是你需要的。\n\ndragon 系统的组件主要使用 java 语言开发。需要在组件项目中导入 `dragon-organ-interface` 包。所有包含接口的类需要继承自 `Organ` , 所有接口方法需要添加 `Call` 注解。然后将组件编译为 `jar` 包，放入项目的 `jars` 目录下，Dragon-IDE 就可以扫描到新编写的组件了。\n\n\n虽然接口是 java 的，但是不一定必须使用 java 实现组件的具体功能。可以通过 java 连接其他编程语言，或者远程调用，或者其他 jvm 语言，等等多种方式实现丰富的功能扩展。\n\n\n\n\n');
INSERT INTO `wiki_doc` VALUES ('21', '#内核开发\n\n如果你愿意给 dragon 系统的解决bug、添加新特性、扩展功能，这里的内容可能会有帮助。');
INSERT INTO `wiki_doc` VALUES ('23', '#IDE 开发\n\ndragon 系统作为一种可视化编程方案，对 IDE 有特别高的依赖。\n\nDragon-IDE 是基于 electron ， 主要使用 javascript 编写而成， 支持 windows （Win7+）、Linux 、 Mac 多平台运行。');
INSERT INTO `wiki_doc` VALUES ('24', '#简介\n\nDragon 系统起源于一个想法：将功能都封装成独立的组件，然后用流程图的方式串起来。提供可视化的编辑界面，只要流程画清楚了，功能也就实现了。这个想法来自于目前已经在使用的一套支付密码系统的后台，然后又将该想法扩展到了 Web 领域。根本目的为了应对快速的业务变化，减少人力资源支出。\n\n\n由流程串起来的一系列组件看起来就像一条龙，所以选择了 Dragon 这个名字和机械龙 Logo\n\n[![dragon](http://omlsa8p3j.bkt.clouddn.com/dragon.jpg \"dragon\")](http://omlsa8p3j.bkt.clouddn.com/dragon.jpg \"dragon\")\n\n\n\n##TODO\n\nDragon 系统目前已经可以使用，最初设想的基本功能已经实现。事实上目前你看到的文档系统的后台就是使用 Dragon 编写的。\n\n但是依然有诸多细节可以改善，以及有更多特性可以加进来，开发原来可以如此简单。\n\n\n## IDE 改进\n- 参数编辑器重写\n- Ctrl+C Ctrl+V 功能');
INSERT INTO `wiki_doc` VALUES ('30', '#打包\n\n\n执行引擎( Dragon.jar )\n - 更新后需要更新 `electron` 项目下 `resource/war/WEB-INF/lib/Dragon.jar` 。\n - 需要更新 IDE `workspace` 目录下 `.workspace` 目录下的运行时 `Dragon.jar`。\n\n\n\n\n\n系统组件更新后 ，需要更新。\n\n\n## 运行于 web 容器内\n\n1. 打包时将所有配置文件放入默认资源路径，程序启动后从资源路径下以流的方式读取所需内容。\n2. 运行时和依赖拷入lib目录，可以不使用自定义 classloader 载入。\n3. 模型定义需要预先被扫描生成索引，存入 `index.json`。\n4. 模版定义需要预先被扫描生成索引，存入 `index.json`。\n5. 测试报文被忽略。\n6. 一般只有 Api 形式为 http 协议的服务才放在 web 容器内。实现方式是，编写一个通用的 servlet 拦截器，将所有的请求转成 xml 报文。\n7. 监听的端口由 tomcat 配置决定。\n\n\n\n## 运行于 jstrom DRPC模式\n\n\n');
INSERT INTO `wiki_doc` VALUES ('31', '#web 转 xml 报文格式\n\n\n> 不确定 web 请求如何转为 xml 报文，可以使用 [报文在线查看](http://172.16.18.189:8080/util/web/xmlshow.html)\n\n一个 web 请求转为 xml 之后的报文如下：\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web>\n    <stamp/>\n    <request>\n        <url>/project/list</url>\n        <urls>\n            <value/>\n            <value>project</value>\n            <value>list</value>\n        </urls>\n        <session/>\n        <params>\n            <name>huangqian</name>\n            <type>man</type>\n        </params>\n    </request>\n</web>\n```\n\n\n所有字段包含在 web 标签下。\n- stamp 标签下的内容用于异步请求返回。通常不用理会。\n- request 标签下包含了所有请求参数。\n	- url 是完整的请求 url。\n	- urls 标签下是切割后的 url 请求。\n	- session 标签下是会话相关内容。\n	- params 标签下是 js 传递的参数。\n\n\n\n\n\n');
INSERT INTO `wiki_doc` VALUES ('32', '#别名注册');
INSERT INTO `wiki_doc` VALUES ('33', '#组件接口详细说明\n\n先看一个接口的例子，这就是内置的文件操作组件的源码：\n\n```java\npackage com.sunyard.dragon.organ;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport com.sunyard.dragon.organ.util.StringUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.util.List;\n\n/**\n * Created by Cheney on 2016/12/30.\n */\npublic class File extends Organ{\n    private static Logger logger = LoggerFactory.getLogger(File.class);\n\n    @Call(\"基于 url 读取文件内容\")\n    public static Object urlStaticFile(\n            @I(\"完整 url\")\n                    String url,\n            @I(\"静态文件存放路径\")\n                    String basepath,\n            @O(value=\"文件内容\",clazz = String.class)\n                    Output contents,\n            @O(value=\"文件类型\",clazz = String.class)\n                    Output doctype\n    ){\n        try {\n            String path = url.substring(4);\n            String filePath = basepath + path;\n\n            System.err.println(filePath);\n\n            // 过滤分隔符\n            int sep1 = filePath.indexOf(\"?\");\n            int sep2 = filePath.indexOf(\"#\");\n            int sep = Integer.max(sep1,sep2);\n\n            if (sep > 0){\n                filePath = filePath.substring( 0, sep );\n            }\n\n            String fileType = \"\";\n            int dot = filePath.lastIndexOf(\".\");\n            if (dot > 0){\n                fileType = filePath.substring(dot);\n            }\n\n            java.io.File f = new java.io.File(filePath);\n            if (f.exists() && (!f.isDirectory())){\n                String content = StringUtil.streamToString(\n                        new FileInputStream(f)\n                );\n                contents.set(content);\n                doctype.set(fileType);\n                logger.debug(\"read length\", content.length());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            contents.set(\"\");\n            doctype.set(\"error\");\n            logger.error(\"读取文件错误\", e);\n        }\n        return RET_SUCCESS;\n    }\n\n\n    @Call(\"获取文件列表\")\n    public static Object list(\n        @I(\"路径\")\n        String path,\n        @O(value=\"文件列表\",clazz = List.class)\n                Output contents\n    ){\n        try {\n            java.io.File f = new java.io.File(path);\n            if (f.exists() && f.isDirectory()){\n                contents.set(f.list());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return RET_SUCCESS;\n    }\n\n    @Call(\"获取文本文件内容\")\n    public static Object readContent(\n            @I(\"路径\")\n                    String path,\n            @I(\"文件名\")\n                    String fileName,\n            @O(value=\"文件内容\",clazz = String.class)\n                    Output contents\n    ){\n        try {\n            java.io.File f = new java.io.File(path,fileName);\n            if (f.exists() && (!f.isDirectory())){\n                String content = StringUtil.streamToString(\n                        new FileInputStream(f)\n                );\n                contents.set(content);\n                logger.debug(\"read length\", content.length());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return RET_SUCCESS;\n    }\n\n\n    @Call(\"将 json 文件内容保存到 key值命名的文件\")\n    public static Object saveJsonToKeyFiles(\n            @I(\"路径\")\n                    String path,\n            @I(\"扩展名\")\n                    String type,\n            @I(\"json\")\n                    String json\n            ) throws IOException {\n        java.io.File folder = new java.io.File(path);\n        if (folder.exists() && folder.isDirectory()){\n\n            JSONObject j = JSON.parseObject(json);\n\n            for (String key : j.keySet()){\n                java.io.File file = new java.io.File(folder.getPath(), key + type);\n                if ( ! file.exists()){\n                    file.createNewFile();\n                }\n\n                FileWriter fileWriter = new FileWriter(file);\n                fileWriter.write(j.getString(key));\n                fileWriter.flush();\n                fileWriter.close();\n            }\n\n        }\n\n        return RET_SUCCESS;\n    }\n\n    @Call(\"将内容写入文件\")\n    public static Object save(\n            @I(\"文件内容\")\n                    String content\n    ){\n        try {\n            java.io.File f = java.io.File.createTempFile(\"temp\",\"xml\");\n            FileOutputStream fOs = new FileOutputStream(f);\n            fOs.write(content.getBytes());\n            fOs.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return RET_SUCCESS;\n    }\n\n}\n\n```\n\n\n## Organ 类\n\n`organ` 类是个抽象类，主要起到标记组件类的作用，方便扫描器扫描组件。同时定义了两个 `final` 变量作为常用的组件方法的返回值。\n\n- `RET_SUCCESS` 表示流程执行正确。\n- `RET_OVER` 表示流程执行结束。\n\n>注：\n组件方法的返回值只用来控制流程的执行。\n真正要返回的内容要通过 output 类输出。\n\n\n## call 注解\n`call` 注解用来标记需要导出的组件，每个组件其实是一个 java 的 `static` 方法。\n\n`call` 注解接收一个参数作为组件的名字\n\n\n## I 注解\n`I` 注解表示一个参数为输入参数。输入参数的类型可以是 dragon-lang  支持的所有类型。\n\n`I` 注解接收一个参数作为该变量的注释。\n\n\n## O 注解\n`O` 注解表示一个参数为输出参数。输出参数的类型只能是 `Output` ，真正的执行结果返回是通过调用  `Output` 类的 `set` 方法实现的。可以有多个输出。\n\n\n\n\n');
INSERT INTO `wiki_doc` VALUES ('34', '#特殊组件');
INSERT INTO `wiki_doc` VALUES ('35', '#组件分组与排序\n\n组件分组通过 `Call` 注解上的 `group` 属性来配置。序号越小越靠前。项目序号的组件按照定义顺序来显示。\n');
INSERT INTO `wiki_doc` VALUES ('36', '#项目结构一览\n\n### frame 后台交互相关\n- api: 系统提供的公共API\n- vars: 全局的常量map\n  - resource : 内置资源路径\n  - workspace: 工作空间的路径\n  - project: 工程名称\n  - type：工程类型 (socket|web)\n- debug 调试模块封装\n- cmd 命令与 java 通信接口\n- async electron 框与内部通信模块\n- file: 文件操作模块封装\n- menu: 菜单模块\n\n### web 前端模块\n- bpmn 流程编辑相关\n- bpmn.js bpmn 库\n- bpmn-js-properties-panel 组件属性编辑器 （需重写）\n- diagram-js svg 底层支持库\n- breadcrumb 面包屑导航栏\n- jsonc 非标准 json 去除注释工具\n- comm 通信相关\n- css 样式\n- imgs 图片\n- js 其他 js\n\n\n### components Vue 模块\n- VueApp Vue 组件总入口\n- tree 重写自 elements ui，提供原生事件支持\n- infopad 调试信息展示栏\n- organTree 组件树\n');
INSERT INTO `wiki_doc` VALUES ('37', '#IDE 的发布\n\nIDE 中的新建 workspace 、新建项目、新建流程等工具都是通过调用 shell 拷贝模版来实现的。在打包发布之前要确认模版文件都存在。');
INSERT INTO `wiki_doc` VALUES ('38', '#业务项目目录一览\n\n##config 目录\nconfig 目录存放配置文件相关。\n\nmain.json 是项目的主要配置文件，可以添加通用的 kv 键值对配置，工程中通过 cfg.xxx 形式可以读到。\n\ndb.json 是项目数据库相关的配置文件。可以配置多个数据库，主数据库默认名为 `main`\n\n其他自定义配置，可以根据具体情况编写，但是不会自动载入。需要在启动命令上添加 `-cfg [配置名]` 来载入更多个性化配置。\n\nindex.json 是项目打包时自动生成的索引配置，一般不需要人工修改。\n\n\n\n');
INSERT INTO `wiki_doc` VALUES ('39', '#SmartSql\n\n对于常用的简单 `select`、 `insert` 、 `update` 、 `delete` 存在重复的代码编写。SmartSql 就是遵照一个简单的模型简化常用的简单 sql 编写。\n\n\n## URL 规范\n为了方便后台配置，URL 建议使用单词间隔的风格编写。例如:\n查询所有项目`/project/list`， 根据实际情况和模块划分，可以自定义扩展 URL， `/module1/submodule/object/method`。\n\n## 表名\n使用 SmartSql 组件不需要直接写 Sql 而是需要填写要查询的表。为了保护数据库中的表名，通常会对表明进行变换，或者提供别名，这些都可以在【数据源】工具栏中配置。\n\n`insert` 、 `update` 、 `delete` 都只能操作单表。select 可以进行并表。如果需要直接并表，表明可以写为 `table1-table2-table3`，最终结果为 `table1` 为主表，`left join` 其他表的结果。\n\n对于一对多的并表, 需要在表明前面加上 `[` ， 例如: `table1-[table2-table3`, 表示 `table1` 和 `table2` 是一对多的关系。\n\n\n\n## 参数\nsql 参数通过 http 请求参数提交:\n比如过滤在获取项目列表时过滤项目类型。则发送 `/project/list` 参数为 ：\n\n```\n{\n\"project\" : {\n		\"type\" : \"1\" \n	}\n}\n```\n> 需要用到 http 扩展协议\n\n\n## 过滤器\n全局过滤器和组过滤器都在【数据源】工具栏中配置。命名为 `global` 的组过滤器会自动生效，其他过滤器需要作为组件参数传入。\n\n组过滤器由基本过滤器组成。\n\n基本过滤器：\n- 黑名单表过滤器\n- 黑名单字段过滤器\n- 白名单表过滤器\n- 白名单字段过滤器\n- 主键过滤器\n- Where 过滤器\n\n\n基本过滤器也可以直接作为组件参数使用\n\n## 问题\n\nSmartSql 目前存在如下问题：\n\n一对多并表查询时问题：\n\n1. group concat 字符串超长问题\n解决方法：\n	调整 mysql 配置中 group_concat_max_len=65535\n\n2. concat 字段转义问题\n带有未转义的引号的字符串在拼装中间 json 时有问题。\n解决方法：\n	1. 使用 jsonEscape 转义\n	2. 使用其他方式转义，比如：base64 编码\n	\n3. `查询 list 后 group` 和 `分页` 与 一对多查询冲突\n如果使用了包含一对多的查询，则不能使用 sql 表达式注入 group sql\n解决方法：\n	1. 拆分为两次查询\n');
INSERT INTO `wiki_doc` VALUES ('40', '#通信帧\n\n`com.sunyard.dragon.comm.frame` 包下定义了通信和执行中用到的帧。\n\n所有帧的父类是 `Frame`, `Frame` 是抽象类，只关心 `connect` 和 `service` ， `connect` 标记了这个帧从哪里来，一般情况下，从哪里来就必须从哪里返回。 `service` 指定了这个帧将被分发到那个具体的执行引擎，只有多引擎模式才会起效。\n\n运行时用的帧主要是 `XMLFrame` ，Dragon 的执行中主要就是依赖  `XMLFrame` 或者他的子类。如果原始报文就是 XML ，那么就直接使用  `XMLFrame`，如果原始报文是从 web 发起的，那么会用到 `XMLFrame` 的两个子类： `NettyWeb2XmlFrame` 和 `ServletWeb2XmlFrame` ， 如果使用自建的 httpserver， 那么帧类型就是 `NettyWeb2XmlFrame`，如果程序运行于某种 web 容器中（比如，tomcat）, 那么帧类型就是 `ServletWeb2XmlFrame`。也就是说每一个 web 请求都会被转换成一个 XML 请求。具体转换细节参考 **流程开发/报文/web 转 xml 报文格式**。\n\n');
INSERT INTO `wiki_doc` VALUES ('42', '#组件图标\n\n组件由 `call` 注解的 `icon 属性指定，默认值是 \'bpmn:Task\'，可选的值有 ：\n\n	\'bpmn:Event\'\n    \'bpmn:StartEvent\'\n    \'bpmn:MessageEventDefinition\'\n    \'bpmn:TimerEventDefinition\'\n    \'bpmn:EscalationEventDefinition\'\n    \'bpmn:ConditionalEventDefinition\'\n    \'bpmn:LinkEventDefinition\'\n    \'bpmn:ErrorEventDefinition\'\n    \'bpmn:CancelEventDefinition\'\n    \'bpmn:CompensateEventDefinition\'\n    \'bpmn:SignalEventDefinition\'\n    \'bpmn:MultipleEventDefinition\'\n    \'bpmn:ParallelMultipleEventDefinition\'\n    \'bpmn:EndEvent\'\n    \'bpmn:TerminateEventDefinition\'\n    \'bpmn:IntermediateEvent\'\n    \'bpmn:Activity\'\n    \'bpmn:Task\'\n    \'bpmn:ServiceTask\'\n    \'bpmn:UserTask\'\n    \'bpmn:ManualTask\'\n    \'bpmn:SendTask\'\n    \'bpmn:ReceiveTask\'\n    \'bpmn:ScriptTask\'\n    \'bpmn:BusinessRuleTask\'\n    \'bpmn:SubProcess\'\n    \'bpmn:AdHocSubProcess\'\n    \'bpmn:Transaction\'\n    \'bpmn:CallActivity\'\n    \'bpmn:Participant\'\n    \'bpmn:Lane\'\n    \'bpmn:InclusiveGateway\'\n    \'bpmn:ExclusiveGateway\'\n    \'bpmn:ComplexGateway\'\n    \'bpmn:ParallelGateway\'\n    \'bpmn:EventBasedGateway\'\n    \'bpmn:Gateway\'\n    \'bpmn:SequenceFlow\'\n    \'bpmn:Association\'\n    \'bpmn:DataInputAssociation\'\n    \'bpmn:DataOutputAssociation\'\n    \'bpmn:MessageFlow\'\n    \'bpmn:DataObject\'\n    \'bpmn:DataObjectReference\'\n    \'bpmn:DataInput\'\n    \'bpmn:DataOutput\'\n    \'bpmn:DataStoreReference\'\n    \'bpmn:BoundaryEvent\'\n    \'bpmn:Group\'\n    \'bpmn:TextAnnotation\'\n    \'ParticipantMultiplicityMarker\'\n    \'AdhocMarker\'\n');
INSERT INTO `wiki_doc` VALUES ('46', '#sql 基础\n\n使用数据库相关的组件需要一定的 sql 基础。需要掌握几种常用的 sql 写法。`select`、`insert`、`update`、`delete`。\n\n\n## SELECT 语句\nselect 语法用来从数据库中取出数据。\n>注释：SQL 语句对大小写不敏感。SELECT 等效于 select。\n\n语法\n```\nSELECT 列名称 FROM 表名称\n```\n或者写成\n```\nSELECT * FROM 表名称\n```\n\n举个例子:\n如需获取名为 \"LastName\" 和 \"FirstName\" 的列的内容（从名为 \"Persons\" 的数据库表），请使用类似这样的 `SELECT` 语句：\n`SELECT LastName,FirstName FROM Persons`\n\n\n## INSERT INTO 语句\nINSERT INTO 语句用于向表格中插入新的行。\n语法：\n```\nINSERT INTO 表名称 VALUES (值1, 值2,....)\n```\n\n也可以指定所要插入数据的列：\n```\nINSERT INTO table_name \n	(列1, 列2,...) \nVALUES \n	(值1, 值2,....)\n```\n\n## Update 语句\nUpdate 语句用于修改表中的数据。Update 语句一般都会带上 WHERE 参数作为过滤条件，否则会更新表中所有数据。\n语法：\n```\nUPDATE 表名称 \n	SET 列名称 = 新值\n	, 列名称2 = 值2 \nWHERE 列名称 = 某值\n```\n\n\n## DELETE 语句\nDELETE 语句用于删除表中的行，DELETE 语句一般都会带上 WHERE 参数作为过滤条件，否则会删掉所有数据。\n语法\n```\nDELETE FROM 表名称 WHERE 列名称 = 值\n```\n\n\n\n\n');
INSERT INTO `wiki_doc` VALUES ('47', '#sql 模版语法扩展\n\n了解 sql 语法基础之后就可以在项目中使用，但是通常程序中的 sql 不是固定的，而是在某些位置存在变量，根据变量不同成为不同的 sql。\n\n参考 mybatis 的语法，我们可以根据变量在程序中生成动态的 sql 。\n\n## 变量\n在模版语法中使用 `#{变量名}` 或 `${变量名}` 形式将 sql 的指定位置替换为变量的值。\n\n例如:\n```sql\ninsert into t_user (username,password) values (#{username},#{password})\n```\n\n如果程序中存在变量 `username` 的值为 `小黄`， `password` 的值为 `123456`, 那么最终发给数据库的 sql 为:\n```\ninsert into \n	t_user (username,password) \n	values \'小黄\',\'123456\'\n```\n\n### # 和 $ 的不同\n\n`#` 将变量的值以字符串的形式传递给数据库, `$` 将变量以值的形式传递给数据库。\n\n`#` 其实提供了 sql 防注入的功能，有较高的安全性。几乎所有的情况都应该使用 `#`。\n\n`$` 没有安全性检查，有可能导致安全性问题，只有在某些特定情况下才使用。\n\n### xml 特殊字符转义\n|  原始符号 | 转义符号  |\n| :------------: | :------------: |\n| &(逻辑与)   |  `&amp;`  |\n| <(小于)   |  `&lt;`   |\n| >(大于)  |  `&gt;`  |\n| \"(双引号)  | `&quot;`  |\n| \'(单引号) | `&apos;` |\n\n## 控制语句\n我们不只可以替换 sql 中的某些地方为变量值，还可以通过变量控制 sql 语句本身，以实现更加灵活的 sql 。\n\n\n### if test\n\n`if test` 语句用来判断一个变量的值的表达式是否为真，从而控制某些 sql 段是否存在于最终生成的 sql 中。\n\n```\nUPDATE user\n<if test=\"name != null\">\n	SET name = name\n</if>\n<if test=\"tel != null\">\n	,tel = tel\n</if>\n<if test=\"sex != null\">\n	,sex = sex\n</if>\nWHERE id=#{id}\n```\n\n比如说我们传入的值是 :\n```json\n{\n	id : \'001\'\n	name : \'小黄\',\n	tel : \'110\'\n}\n```\n上面的 sql 最终输出是 : \n```\nUPDATE user\nSET name = \'小黄\'\n,tel = \'110\'\nWHERE id=\'001\'\n```\n\n这是一个正确的 sql，当我们没传 tel 的时候，也可以得到一个正确的 sql。当我们没传 name 的时候 sql 会有问题， sql 中的 `SET` 没有输出。\n改进的方法是通过 `trim` 标签解决这个问题。\n\n\n### trim\n\ntrim 标签有四个属性：\n- prefix：前缀覆盖并增加其内容\n- suffix：后缀覆盖并增加其内容\n- prefixOverrides：前缀判断的条件\n- suffixOverrides：后缀判断的条件\n\n\n上面的例子写成：\n\n```\nUPDATE user\n<trim prefix=\"set\" suffixOverrides=\",\">\n	<if test=\"name != null\">\n		name = name\n	</if>\n	<if test=\"tel != null\">\n		tel = tel\n	</if>\n	<if test=\"sex != null\">\n		sex = sex\n	</if>\n</trim>\nWHERE id=#{id}\n```\n\n这样就没有丢掉 set 或者多出 逗号的问题了。\n\ntrim 标签也常用于 where 字段，实现根据传递的参数来修改 sql 的过滤条件。\n```\nselect * from user where 1 = 1\n\n<trim suffix=\"WHERE\" suffixOverrides=\"AND | OR\">\n    <if test=\"id != null and id !=\'\' \">\n        AND b.id =#{id}\n    </if>\n    <if test=\"name != null\">\n        AND b.menu_name like #{name}\n    </if>\n</trim>\n```\n其实 `<trim suffix=\"WHERE\" suffixOverrides=\"AND | OR\">` 可以简写成 `<where>`\n\n\n\n');
INSERT INTO `wiki_doc` VALUES ('48', '#数据库组件\nDragon 提供了大量的数据库操作数组，功能上大多类似，细节上略有不同，使用的时候可以根据具体情况挑选。\n\n## 最基础的四个组件\n- 执行 sql 查询\n- 执行 sql 单值查询\n- 执行 sql 更新\n- 执行 sql 插入\n\n### 执行 sql 查询\n执行 sql 查询对应于数据库操作的 `select`，返回结果是 Record 值的列表，即使真正的查询结果只有一个也是一个列表结构。JSON 化之后是个数组套对象。\n\n### 执行 sql 单值查询\n执行 sql 查询对应于数据库操作的 `select`，返回结果是一个 Record 值的列表。JSON 化之后是个对象。\n\n### 执行 sql 更新\n执行 sql 查询对应于数据库操作的 `insert`、`update`、`delete`。即除了 `select` 之外的 sql 都可以用这个组件。\n\n### 执行 sql 插入\n执行 sql 查询对应于数据库操作的 `insert`，只用于需要获取插入后获取数据库自动生成的组件的情况。\n\n\n## 主数据库 sql 组件\n- 主数据库中执行 sql 查询\n- 主数据库中执行 sql 单值查询\n- 主数据库中执行 sql 更新\n- 主数据库中执行 sql 插入\n- 设置主主数据库名\n\n主数据库 sql 组件和基础数据相同，只是不用传第一个参数数据库名。默认使用名字为 `main` 的数据库。也可以通过`设置主主数据库名`修改全局默认主数据库。\n\n\n\n\n## 智能 sql\n\n- 智能 sql 查询\n- 智能 sql 单值查询\n- 智能 sql 更新\n- 智能 sql 插入\n\n- 主数据库中智能 sql 查询\n- 主数据库中智能 sql 单值查询\n- 主数据库中智能 sql 更新\n- 主数据库中智能 sql 插入\n\n和基础数据功能相同，只是需要填写更少的参数，具体语法参考 SmartSql 章节。\n\n');
INSERT INTO `wiki_doc` VALUES ('49', '#配置\n\n可以通过 IDE 右侧的配置工具栏，编辑一组键值形式的配置，组件可以在运行时读取到这些配置。\n\n配置工具栏中可以新建情景，发布环境和测试环境配置通常是不一样的，最佳实践是 debug 创建一组配置， public 创建一组配置。在打包之前切换到需要的配置情景状态。\n\n\n## 系统配置\n系统占用了一部分配置的键值，自定义配置请不要与系统配置重名。\n\n- $webConfig\n	 IDE 在打包时基于该配置切换了前端的配置文件。`$webConfig` 对应的 js 文件将被拷贝为名为 `config.js` 的文件。通常在此文件中配置 url 路径以实现动态的 api 路径。\n	 \n	 \n- $type\n	IDE 依赖此值开启调试进程，通常不要改变。\n	\n\n\n');
INSERT INTO `wiki_doc` VALUES ('50', '#数据源\n\n项目中如果要使用数据库，需要现在 IDE 右侧数据源工具栏中新增一个数据库配置项，默认数据库一般叫 `main` 。\n\n## 基础配置\n数据源配置项中， jdbc 组下的参数为必填项，如果填写错误将不能连接到数据库。\n\n如果不使用 smartSql 相关组件，之后的配置都不需要关系了，只配置基础配置项就够了。\n\n\n## 别名定义和别名转换\n\n> 别名定义和别名转换只对 smartSql 相关组件有效\n\n通常我们不希望数据表名称或字段名称直接暴漏在外，通常表名会有统一的前缀，为了方便输入，可以通过设置别名定义和别名转换来增加安全性和简化输入。\n\n\n\n');
INSERT INTO `wiki_doc` VALUES ('51', '#模版\n\n为了简化报文发送，可以通过将报文预先定义出来，当发送的时候渲染其中的变量，生成完整的报文发送出去。\n\n模版语法使用 `freemarker` 语法。');
INSERT INTO `wiki_doc` VALUES ('52', '#xpath\n\n报文本质上是个 xml，通过读取 xml 的节点，可以获取报文中的信息。\n\n> 检查 xpath 有没有写对可以用 [xpath 在线测试](http://172.16.18.189:8080/util/web/xmlshow.html) ，解析方式和运行时保持相同，其中包含了扩展语法。\n\n## 路径表达式\n- 斜杠（/）作为路径内部的分割符。\n- 同一个节点有绝对路径和相对路径两种写法。\n	- 绝对路径（absolute path）必须用\"/\"起首，后面紧跟根节点，比如/step/step/...\n	- 相对路径（relative path）则是除了绝对路径以外的其他写法，比如 step/step，也就是不使用\"/\"起首。\n- \".\"表示当前节点。\n- \"..\"表示当前节点的父节点\n- \"|\"选择多个并列的路径。\n\n## 节点选择\n- nodename（节点名称）：表示选择该节点的所有子节点\n- \"/\"：表示选择根节点\n- \"//\"：表示选择任意位置的某个节点\n- \"@\"： 表示选择某个属性\n\n\n### 例子\n```xml\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<bookstore>\n  <book>\n    <title lang=\"eng\">Harry Potter</title>\n    <price>29.99</price>\n  </book>\n  <book>\n    <title lang=\"eng\">Learning XML</title>\n    <price>39.95</price>\n  </book>\n</bookstore>\n```\n\n- bookstore ：选取 bookstore 元素的所有子节点。\n- /bookstore ：选取根节点bookstore，这是绝对路径写法。\n- bookstore/book ：选取所有属于 bookstore 的子元素的 book元素，这是相对路径写法。\n- //book ：选择所有 book 子元素，而不管它们在文档中的位置。\n- bookstore//book ：选择所有属于 bookstore 元素的后代的 book 元素，而不管它们位于 bookstore 之下的什么位置。\n- //@lang ：选取所有名为 lang 的属性。\n- //book/title | //book/price ：表示同时选择book元素的title子元素和price子元素。\n\n## 谓语\n所谓\"谓语条件\"，就是对路径表达式的附加条件。\n所有的条件，都写在方括号\"[]\"中，表示对节点进行进一步的筛选。\n\n- /bookstore/book[1] ：表示选择bookstore的第一个book子元素。\n- /bookstore/book[last()] ：表示选择bookstore的最后一个book子元素。\n- /bookstore/book[last()-1] ：表示选择bookstore的倒数第二个book子元素。\n- /bookstore/book[position()<3] ：表示选择bookstore的前两个book子元素。\n- //title[@lang] ：表示选择所有具有lang属性的title节点。\n- //title[@lang=\'eng\'] ：表示选择所有lang属性的值等于\"eng\"的title节点。\n- /bookstore/book[price] ：表示选择bookstore的book子元素，且被选中的book元素必须带有price子元素。\n\n\n\n##通配符\n\n- \"*\"表示匹配任何元素节点。\n- \"@*\"表示匹配任何属性值。\n- node()表示匹配任何类型的节点。\n\n\n\n- //* ：选择文档中的所有元素节点。\n- /*/* ：表示选择所有第二层的元素节点。\n- /bookstore/* ：表示选择bookstore的所有元素子节点。\n- //title[@*] ：表示选择所有带有属性的title元素。\n\n');
INSERT INTO `wiki_doc` VALUES ('53', '#http 协议扩展\n因为 html 原生不能传递复杂对象，所以对 html 传输内容进行扩展，使 post 请求能够传递更大的数据量。\n\n如果需要传递嵌套的对象，则只在 post 中提供一个特殊对象 `j$on`, 其值为字符串化的 json 对象，`j$on`本身会被擦除，就像不存在一样。json 对象将会被解析一层，值为简单类型的 key-value, 作为第一层参数。或者通过方法 `map()` 读取的将是 `json`类型。\n\n\n');
INSERT INTO `wiki_doc` VALUES ('54', '#报文\n\nDragon 本质上是基于 xml 报文来完成，但是内部同时集成了 web 请求到 xml 报文的转换，所以看起来可以直接处理 web 请求。\n\n由于原始 http 协议提交中不能直接提交嵌套的对象，这不利于大量数据对象传递，不能发挥 xml 报文的优势，所以 Dragon 对http 协议内部消息传递有个扩充协议。\n\n如果要从报文中获取信息，需要一定的 xpath 知识。');
INSERT INTO `wiki_doc` VALUES ('56', '#模型\n\n为了简化变量和报文读取，可以通过预先定义一个模型，预先规定从什么位置以什么方式读取数据。之后就可以在使用组件时就可以直接把模型作为输入。\n\n这样做的好处：\n1. 应对报文变化\n	当报文有变化时，只需要修改模型，所有依赖就都会使用新的报文，不需要一个个去改。\n2. 输入检查\n	定义模型的时候可以填写预期的读取数据格式，如果格式不符，直接返回错误。\n	\n3. 提高效率\n	从 xml 报文读取之后的值会被缓存掉，重复的读取不需要重新解析 xpath。\n');
INSERT INTO `wiki_doc` VALUES ('57', '#工程构建\n\nDragon 基于 java 编写，请确保已安装 `jdk 1.7` 或以上版本，并且命令行可以调用 `java` 命令。\n\nDragon 运行时是一个标准 Maven 项目，建议使用 IDEA 开发工具打开。\n\n执行 maven 生命周期 :\n1. clean\n2. compile\n3. package\n\n并通过插件 `assembly` 插入所有依赖。\n\n\n\n\n\n\n\n\n');
INSERT INTO `wiki_doc` VALUES ('58', '#SmartSql 接口\n\n数据库组件部分依赖 `dbapi`包，`dbapi` 包对智能 sql 的部分通过 `SmartSql` 来提供。\n\n\n## genSelectSql\n```\npublic static SqlMeta genSelectSql(String db, String tables, Map<String,Map<String,String>> params, FilterGroup filterGroup)\n```\n\n和其他接口不一样， 因为要支持多表过滤，`genSelectSql` 的params 参数为嵌套 map 。\n\n对于前端需要提交为一下形式:\n```\nurl : /project/list\ndata : {\n\"project\" : {\n        \"type\" : \"1\"\n    }\n}\n```\n\n\n## genUpdateSql\n```\npublic static SqlMeta genUpdateSql(String db, String table, Map<String,String> params, FilterGroup filterGroup)\n```\n\n`genUpdateSql` 必须提交过滤参数，常见的过滤参数为 `$pk`， `$pk` 会被自动替换为主键，或者直接传递主键的名字，例如`id`。\n\n\n## genInsertSql\n```\npublic static SqlMeta genInsertSql(String db, String table, Map<String,String> params, FilterGroup filterGroup)\n```\n\n\n\n\n');
INSERT INTO `wiki_doc` VALUES ('59', '#工程构建\n\nDragon 运行时基于 java 编写，请确保已安装 `jdk 1.7` 或以上版本，并且命令行可以调用 `java` 命令。\n\n\n### 安装 node\nDragon IDE 项目是一个 nodejs 项目，首先需要安装 `node`。到官网( http://nodejs.cn/ )安装适合你操作系统的版本，并配置环境变量，使得可以在命令行下调用 `node` 命令和 `npm` 命令。\n\n### 切换源\n由于众所周知的原因，国内无法稳定连接全球源，所以需要将源切换到国内的淘宝源。\n\n编辑当前用户根目录下的 `npmrc` 文件。 linux 系统和 Mac 修改 `~/.npmrc` , 内容修改为。\n\n>找不到 npmrc 文件，可以自己手动创建，或者执行命令 `npm config set registry http://registry.npm.taobao.org`\n\n```\nregistry=https://registry.npm.taobao.org\nsass_binary_site=https://npm.taobao.org/mirrors/node-sass/\nphantomjs_cdnurl=http://npm.taobao.org/mirrors/phantomjs\nELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron/\n```\n\n\n### 安装依赖\n在项目根目录下执行 `npm i` 安装所有依赖。\n\n为了方便执行命令，全局安装以下依赖，使用命令：\n```\nnpm i webpack -g\nnpm i electron -g\nnpm i electron-packager -g\n```\n>此时命令行可以直接调用 `webpack` ， `electron` ， `electron-packager` 命令。\n\n### 运行\n\n首先需要启动 web-hot-server 部分。使用命令:\n```\nnpm start\n```\n执行完成后启动 electron 部分, 使用命令:\n```\nelectron src/frame/run.js\n```\n\n### 发布\n\nDragon IDE 本身是为了兼容多端平台编写的，可以生成多端平台运行的程序。\n\n1. 只打包 javascript 部分命令为 :\n	```\n	npm run packjs\n	```\n	编译后的内容会放在项目根目录的 `dist` 目录下，打包前最好删掉该目录。\n\n2. 生成多端运行程序\n生成多端运行程序需要先执行 javascript 部分的打包。\n```\nnpm run pack\n```\n生成的文件在项目的 `out` 目录下，打包前最好删掉该目录。\n\n3. 只生成对应平台\nwindows 下使用命令：\n```\nnpm run packwin\n```\nmac下使用命令：\n```\nnpm run packosx\n```\n\n4. Windows 下快速生成脚本\nWindows 下可以使用脚本快速生成 win64 的包，不再需要之前的命令。\n```\nmakewin.cmd\n```\n\n\n\n\n\n\n');
INSERT INTO `wiki_doc` VALUES ('60', '#属性编辑器');
INSERT INTO `wiki_doc` VALUES ('61', '#过滤器\n即编辑属性时，点击加号，就能组合各种过滤器，以对参数值进行进一步的操作，以满足不同需求。\n\n#### 注意： 若过滤器只有一个参数，上一行的返回值就是第一个参数，本行可以什么都不填。若有两个或两个以上参数，该行的值就是第二个参数\n\n其中内置提供的一些过滤器如下：\n- `plus` 字符串拼接，输入要拼接的字符串，两个参数\n- `toInt` 将string参数转换为int类型 一个参数\n- `get` 从Map/Record对象中获取指定key的值，或从list/数组中获取指定下标的值，失败返回null\n  - 输入参数：\n    - Object对象 可以是Map/Record类型的k/v对象 或者是list/数组类型的对象\n	- key值 若为k/v对象，取key的值，若为数组类型，取key所在的下标值\n  - 返回值： key的值\n- `subStr` 取子字符串\n  - 输入参数：\n    - 父字符串\n    - 从哪开始截\n	- 截取的长度\n');
INSERT INTO `wiki_doc` VALUES ('62', '#组件详细说明');
INSERT INTO `wiki_doc` VALUES ('63', '#系统组件');
INSERT INTO `wiki_doc` VALUES ('64', '#web组件');
INSERT INTO `wiki_doc` VALUES ('65', '#Json组件');
INSERT INTO `wiki_doc` VALUES ('66', '#文件组件(File)');
INSERT INTO `wiki_doc` VALUES ('67', '#工具组件(Util)');
INSERT INTO `wiki_doc` VALUES ('68', '#特殊组件(Terminal)');
INSERT INTO `wiki_doc` VALUES ('69', '#树形组件');
INSERT INTO `wiki_doc` VALUES ('70', '#网络组件(net)');
INSERT INTO `wiki_doc` VALUES ('71', '#数据库组件(Db)');
INSERT INTO `wiki_doc` VALUES ('72', '#Mock组件');
INSERT INTO `wiki_doc` VALUES ('73', '#本地会话组件');
INSERT INTO `wiki_doc` VALUES ('74', '#分布式会话组件(redis)');
INSERT INTO `wiki_doc` VALUES ('76', '#组件\n\n`Dragon` 系统的核心思想就是通过流程串联一系列的组建来实现功能。`Dragon` 系统的基础组件是 `java` 编写的，放置在项目的 `jars` 目录下，更新 `*.jar` 包就会改变项目中可用的组件，组件在线更新也是这个原理实现的；以后版本可以通过流程实现动态组件。\n\n');
INSERT INTO `wiki_doc` VALUES ('77', '#数据库配置说明\n\n\n```\n{\n    \"main\": {\n        \"jdbc\": {\n            \"type\": \"sqlite\",\n            \"encode\": \"UTF-8\",\n            \"ip\": \"\",\n            \"port\": \"\",\n            \"user\": \"\",\n            \"password\": \"\",\n            \"name\": \"D:/t.db\"\n        },\n        \"alias\": {\n            \"tableAlias\": [],\n            \"rowAlias\": []\n        },\n        \"aliasConverter\": {\n            \"tableAliasConverter\": {\n                \"class\": \"\",\n                \"params\": []\n            },\n            \"rowAliasConverter\": {\n                \"class\": \"\",\n                \"params\": []\n            }\n        },\n        \"middleTable\": [\n            [\n                \"主表\",\n                \"主表外键\",\n                \"附表\",\n                \"附表外键\"\n            ],\n            [\n                \"主表\",\n                \"中间表\",\n                \"附表\"\n            ],\n            [\n                \"主表\",\n                \"主表外键\",\n                \"中间表\",\n                \"中间表主表关联\",\n                \"中间表附表关联\",\n                \"附表\",\n                \"附表外键\"\n            ]\n        ],\n        \"filterGroup\" {\n        		\"global\" : {\n								blackTables : [\"project\",\"bug\"],\n		        		blackRows : {\n		        			\"user\" : [\"info\",\"password\"]\n		        		}\n        		}\n        }\n    }\n}\n```');
INSERT INTO `wiki_doc` VALUES ('78', '#动态脚本组件\n\n## 动态 groovy 脚本执行\n动态 groovy 脚本执行组件可以直接编写 `java` 代码和 `groovy` 代码。方便操作 java 对象。\n\ngroovy 脚本默认注入了几个特殊对象:\n- `$Db` : 就是 `com.sunyard.dragon.organ.Db.class` ， 可以通过它直接调用数据库。\n\n- `$Organ`： 就是 `com.sunyard.dragon.organ.Organ.class` ， 可以通过返回它的属性 `RET_SUCCESS` 和 `RET_OVER` 控制流程执行结果，也可以返回其他字符串。\n\n- `$out` 是组件的输出对象，调用它的 `set` 方法将值输出到流程配置的位置。组件中收到的对象为对象的引用，编辑它就是编辑原来的对象，所以很多时候不需要使用 `$out`， 当不需要时建议输出到 `_` 变量。\n\n- `$stdout` 输出到标准输出流\n\n- `$stderr` 输出到标准错误流');

-- ----------------------------
-- Table structure for wiki_project
-- ----------------------------
DROP TABLE IF EXISTS `wiki_project`;
CREATE TABLE `wiki_project` (
  `id` int(8) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(255) DEFAULT NULL COMMENT '项目名',
  `info` varchar(1000) DEFAULT NULL COMMENT '项目简介',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of wiki_project
-- ----------------------------
INSERT INTO `wiki_project` VALUES ('1', 'dragon', 'Dragon 系统');
INSERT INTO `wiki_project` VALUES ('2', 'api', 'Api 文档暂时记在这里 ');

-- ----------------------------
-- Table structure for wiki_version
-- ----------------------------
DROP TABLE IF EXISTS `wiki_version`;
CREATE TABLE `wiki_version` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `project` int(10) NOT NULL,
  `name` varchar(255) NOT NULL,
  `menu` varchar(10000) NOT NULL DEFAULT '[]',
  `edit_time` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of wiki_version
-- ----------------------------
INSERT INTO `wiki_version` VALUES ('1', '1', '1.0', '[{\\\"id\\\":\\\"24\\\",\\\"name\\\":\\\"简介\\\",\\\"pId\\\":\\\"root\\\"},{\\\"id\\\":\\\"10\\\",\\\"name\\\":\\\"运维部署\\\",\\\"pId\\\":\\\"root\\\"},{\\\"id\\\":\\\"11\\\",\\\"name\\\":\\\"流程开发\\\",\\\"pId\\\":\\\"root\\\"},{\\\"id\\\":\\\"9\\\",\\\"name\\\":\\\"dragon-lang\\\",\\\"pId\\\":\\\"11\\\"},{\\\"id\\\":\\\"76\\\",\\\"name\\\":\\\"组件\\\",\\\"pId\\\":\\\"11\\\"},{\\\"id\\\":\\\"60\\\",\\\"name\\\":\\\"组件属性编辑器\\\",\\\"pId\\\":\\\"76\\\"},{\\\"id\\\":\\\"61\\\",\\\"name\\\":\\\"过滤器\\\",\\\"pId\\\":\\\"60\\\"},{\\\"id\\\":\\\"62\\\",\\\"name\\\":\\\"组件详细说明\\\",\\\"pId\\\":\\\"76\\\"},{\\\"id\\\":\\\"63\\\",\\\"name\\\":\\\"系统组件\\\",\\\"pId\\\":\\\"62\\\"},{\\\"id\\\":\\\"65\\\",\\\"name\\\":\\\"Json 组件\\\",\\\"pId\\\":\\\"63\\\"},{\\\"id\\\":\\\"66\\\",\\\"name\\\":\\\"文件组件(File)\\\",\\\"pId\\\":\\\"63\\\"},{\\\"id\\\":\\\"67\\\",\\\"name\\\":\\\"工具组件(Util)\\\",\\\"pId\\\":\\\"63\\\"},{\\\"id\\\":\\\"68\\\",\\\"name\\\":\\\"特殊组件(Terminal)\\\",\\\"pId\\\":\\\"63\\\"},{\\\"id\\\":\\\"69\\\",\\\"name\\\":\\\"树形组件(tree)\\\",\\\"pId\\\":\\\"63\\\"},{\\\"id\\\":\\\"70\\\",\\\"name\\\":\\\"网络组件(net)\\\",\\\"pId\\\":\\\"63\\\"},{\\\"id\\\":\\\"71\\\",\\\"name\\\":\\\"数据库组件(Db)\\\",\\\"pId\\\":\\\"63\\\"},{\\\"id\\\":\\\"78\\\",\\\"name\\\":\\\"动态脚本组件\\\",\\\"pId\\\":\\\"63\\\"},{\\\"id\\\":\\\"64\\\",\\\"name\\\":\\\"web组件\\\",\\\"pId\\\":\\\"62\\\"},{\\\"id\\\":\\\"72\\\",\\\"name\\\":\\\"Mock 组件\\\",\\\"pId\\\":\\\"64\\\"},{\\\"id\\\":\\\"73\\\",\\\"name\\\":\\\"本地会话组件\\\",\\\"pId\\\":\\\"64\\\"},{\\\"id\\\":\\\"74\\\",\\\"name\\\":\\\"分布式会话组件(redis)\\\",\\\"pId\\\":\\\"64\\\"},{\\\"id\\\":\\\"49\\\",\\\"name\\\":\\\"配置\\\",\\\"pId\\\":\\\"11\\\"},{\\\"id\\\":\\\"48\\\",\\\"name\\\":\\\"数据库\\\",\\\"pId\\\":\\\"11\\\"},{\\\"id\\\":\\\"46\\\",\\\"name\\\":\\\"sql 基础\\\",\\\"pId\\\":\\\"48\\\"},{\\\"id\\\":\\\"47\\\",\\\"name\\\":\\\"sql 模版语法扩展\\\",\\\"pId\\\":\\\"48\\\"},{\\\"id\\\":\\\"39\\\",\\\"name\\\":\\\"SmartSql\\\",\\\"pId\\\":\\\"48\\\"},{\\\"id\\\":\\\"50\\\",\\\"name\\\":\\\"数据源\\\",\\\"pId\\\":\\\"48\\\"},{\\\"id\\\":\\\"54\\\",\\\"name\\\":\\\"报文\\\",\\\"pId\\\":\\\"11\\\"},{\\\"id\\\":\\\"31\\\",\\\"name\\\":\\\"web 转 xml 报文格式\\\",\\\"pId\\\":\\\"54\\\"},{\\\"id\\\":\\\"53\\\",\\\"name\\\":\\\"http 协议扩展\\\",\\\"pId\\\":\\\"54\\\"},{\\\"id\\\":\\\"52\\\",\\\"name\\\":\\\"xpath\\\",\\\"pId\\\":\\\"54\\\"},{\\\"id\\\":\\\"56\\\",\\\"name\\\":\\\"模型\\\",\\\"pId\\\":\\\"11\\\"},{\\\"id\\\":\\\"51\\\",\\\"name\\\":\\\"模版\\\",\\\"pId\\\":\\\"11\\\"},{\\\"id\\\":\\\"20\\\",\\\"name\\\":\\\"组件开发\\\",\\\"pId\\\":\\\"root\\\"},{\\\"id\\\":\\\"33\\\",\\\"name\\\":\\\"组件接口详细说明\\\",\\\"pId\\\":\\\"20\\\"},{\\\"id\\\":\\\"34\\\",\\\"name\\\":\\\"特殊组件\\\",\\\"pId\\\":\\\"20\\\"},{\\\"id\\\":\\\"32\\\",\\\"name\\\":\\\"组件别名注册\\\",\\\"pId\\\":\\\"20\\\"},{\\\"id\\\":\\\"35\\\",\\\"name\\\":\\\"组件分组与排序\\\",\\\"pId\\\":\\\"20\\\"},{\\\"id\\\":\\\"42\\\",\\\"name\\\":\\\"组件图标\\\",\\\"pId\\\":\\\"20\\\"},{\\\"id\\\":\\\"23\\\",\\\"name\\\":\\\"IDE 开发\\\",\\\"pId\\\":\\\"root\\\"},{\\\"id\\\":\\\"59\\\",\\\"name\\\":\\\"工程构建\\\",\\\"pId\\\":\\\"23\\\"},{\\\"id\\\":\\\"36\\\",\\\"name\\\":\\\"IDE项目结构一览\\\",\\\"pId\\\":\\\"23\\\"},{\\\"id\\\":\\\"38\\\",\\\"name\\\":\\\"业务项目目录一览\\\",\\\"pId\\\":\\\"23\\\"},{\\\"id\\\":\\\"37\\\",\\\"name\\\":\\\"IDE 的发布\\\",\\\"pId\\\":\\\"23\\\"},{\\\"id\\\":\\\"21\\\",\\\"name\\\":\\\"内核开发\\\",\\\"pId\\\":\\\"root\\\"},{\\\"id\\\":\\\"57\\\",\\\"name\\\":\\\"工程构建\\\",\\\"pId\\\":\\\"21\\\"},{\\\"id\\\":\\\"40\\\",\\\"name\\\":\\\"通信报文\\\",\\\"pId\\\":\\\"21\\\"},{\\\"id\\\":\\\"77\\\",\\\"name\\\":\\\"数据库配置说明\\\",\\\"pId\\\":\\\"21\\\"},{\\\"id\\\":\\\"58\\\",\\\"name\\\":\\\"SmartSql 接口\\\",\\\"pId\\\":\\\"21\\\"},{\\\"id\\\":\\\"30\\\",\\\"name\\\":\\\"打包\\\",\\\"pId\\\":\\\"21\\\"}]', '2017-03-07 17:29:55');
INSERT INTO `wiki_version` VALUES ('2', '2', '1.0', '[]', '2017-03-07 17:29:55');
